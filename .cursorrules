# Instructions

During you interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

## Tools

Note all the tools are in python. So in the case you need to do batch processing, you can always consult the python files and write your own script.

IMPORTANT: Make better use of the available Python tools! Before diving into implementation, always try to:

1. Use search_engine.py to research solutions and best practices
2. Use web_scraper.py to gather detailed documentation
3. Use llm_api.py for complex analysis tasks
4. Combine tools for a better research workflow

Remember: These tools are here to help make better informed decisions. Use them proactively!

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

- Screenshot Capture:

```bash
python tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

- LLM Verification with Images:

```bash
python tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:

```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot
screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM
response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:

```bash
python ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:

- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.

```bash
python ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```

This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.

```bash
python ./tools/search_engine.py "your search keywords"
```

This will output the search results in the following format:

```bash
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```

If needed, you can further use the `web_scraper.py` file to scrape the web page content.

## Lessons

### Core Lessons

- Use proper TypeScript types and interfaces for better type safety
- When adapting authentication systems, ensure proper session and user type compatibility
- Keep audit events consistent with the system's event types
- Handle rate limiting and security at the adapter level
- Implement proper error handling and audit logging
- Follow HIPAA compliance requirements for authentication and audit trails
- Make better use of available Python tools for research and automation
- Use Web Crypto API for secure end-to-end encryption
- Implement proper key management with versioning
- Use KV store for efficient caching and audit logging
- Add comprehensive event tracking and monitoring
- Ensure proper error handling in encryption/decryption
- Implement efficient filtering and pagination for large datasets
- Use proper date handling for timestamps and ranges

### Recent Fixes

- Implemented end-to-end encryption:
  - Used Web Crypto API for secure encryption
  - Added proper key management and rotation
  - Implemented secure message storage
  - Added comprehensive audit logging

- Enhanced audit system:
  - Added comprehensive event tracking
  - Implemented efficient filtering and search
  - Created responsive audit dashboard
  - Added proper date range handling

- Improved edge performance:
  - Implemented efficient caching strategies
  - Added proper cache invalidation
  - Used React's cache() for better performance
  - Added rate limiting at the edge

### Best Practices

- Use appropriate caching strategies for different data types
- Implement proper monitoring from the start
- Follow progressive enhancement principles
- Consider both vertical and horizontal scaling
- Use secure encryption for sensitive data
- Implement comprehensive audit logging
- Add proper filtering and pagination
- Use efficient caching at the edge
- Handle data consistency in distributed systems
- Implement proper error handling and recovery

## Scratchpad

### Current Task: Setting up Email System

Progress:
[X] Database Schema
  [X] Created email_templates table
  [X] Created email_events table
  [X] Created email_template_versions table
  [X] Created email_analytics table
  [X] Added triggers and functions
[X] Email Service Implementation
  [X] Created EmailService class
  [X] Implemented template management
  [X] Added email tracking
  [X] Added analytics support
[X] Template System
  [X] Created base MJML template
  [X] Created welcome email template
  [X] Created template initialization script
[X] Dependencies and Configuration
  [X] Install required packages
  [X] Fix import paths
  [X] Configure environment variables
  [X] Add environment validation
[X] Testing and Validation
  [X] Test template rendering
    [X] Created template manager tests
    [X] Created template rendering tests
    [X] Added type declarations for tests
  [X] Test email sending
    [X] Created email service tests
    [X] Added Resend client mocks
    [X] Added test cases for all email types
  [X] Test tracking and analytics
    [X] Created EmailAnalyticsService tests
    [X] Added delivery metrics tests
    [X] Added engagement metrics tests
    [X] Added time-based metrics tests
    [X] Added recipient metrics tests

✨ Email System Setup Complete! ✨

### Best Practices:
- Use MJML for responsive email templates
- Implement proper email tracking
- Follow email deliverability best practices
- Use proper template versioning
- Track email analytics
- Handle rate limiting
- Implement proper error handling
- Use TypeScript for type safety
- Validate environment variables
- Use proper Redis caching
- Write comprehensive tests
- Mock external dependencies in tests
- Use proper type declarations for mocks

### Recent Fixes:
- Created comprehensive email database schema
- Implemented email service with tracking
- Added template management system
- Created base email templates
- Fixed package manager configuration from yarn to pnpm
- Installed required dependencies (mjml, @types/mjml, resend, @upstash/redis)
- Fixed import paths in tsconfig.json
- Created logger implementation
- Added Redis cache configuration
- Added environment variable validation
- Updated services to use validated environment variables
- Created test suites for template rendering
- Added type declarations for test dependencies
- Created test suite for email sending
- Added proper mocking for external services

### Lessons Learned:
- Always validate environment variables using a schema
- Use proper TypeScript types for better type safety
- Handle Redis client types carefully
- Keep services properly configured with environment variables
- Use proper error handling in services
- Implement proper logging and monitoring
- Write tests before implementing features when possible
- Mock external dependencies in tests
- Add proper type declarations for dependencies
- Extract mock functions for better test maintainability
- Use proper typing for mock functions
