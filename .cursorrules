# Instructions

During you interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

## Tools

Note all the tools are in python. So in the case you need to do batch processing, you can always consult the python files and write your own script.

IMPORTANT: Make better use of the available Python tools! Before diving into implementation, always try to:

1. Use search_engine.py to research solutions and best practices
2. Use web_scraper.py to gather detailed documentation
3. Use llm_api.py for complex analysis tasks
4. Combine tools for a better research workflow

Remember: These tools are here to help make better informed decisions. Use them proactively!

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

- Screenshot Capture:

```bash
python tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

- LLM Verification with Images:

```bash
python tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:

```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot
screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM
response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:

```bash
python ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:

- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.

```bash
python ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```

This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.

```bash
python ./tools/search_engine.py "your search keywords"
```

This will output the search results in the following format:

```bash
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```

If needed, you can further use the `web_scraper.py` file to scrape the web page content.

## Lessons

### Core Lessons

- Use proper TypeScript types and interfaces for better type safety
- When adapting authentication systems, ensure proper session and user type compatibility
- Keep audit events consistent with the system's event types
- Handle rate limiting and security at the adapter level
- Implement proper error handling and audit logging
- Follow HIPAA compliance requirements for authentication and audit trails
- Make better use of available Python tools for research and automation:
  - Use search_engine.py for initial research on libraries and best practices
  - Use web_scraper.py for gathering detailed documentation
  - Use llm_api.py for analyzing complex technical decisions
  - Combine tools for a more thorough research workflow

### Recent Fixes

- Fixed PocketBase adapter type issues:
  - Moved PocketBase-specific interfaces to the adapter file
  - Updated audit event types to match system requirements
  - Fixed session user initialization
  - Improved type safety in authentication flow
  - Added proper error handling and audit logging

- Improved research workflow:
  - Started using search_engine.py more consistently
  - Combined search results with web_scraper.py for deeper analysis
  - Better utilization of Python toolkit for research tasks

## Scratchpad

### Current Progress (Based on Roadmaps)

#### Completed Features

[X] UI/UX Core Features
  [X] Dark Mode Implementation
  [X] Component Theming
  [X] Accessibility Implementation
  [X] Interactive Components

[X] Authentication System
  [X] User Management
  [X] Security Features
  [X] Password Management UI
  [X] Email System Integration

[X] HIPAA Compliance Core
  [X] Audit Logging
  [X] Data Retention
  [X] Compliance Reporting
  [X] BAA Management
  [X] Encryption Key Rotation
  [X] Secure Backup Procedures

[X] HIPAA Compliance (Final Phase)
  [X] Core Infrastructure
  [X] Dashboard Implementation
  [X] Compliance Violation Detection
    [X] Real-time monitoring
    [X] Violation alerts
    [X] Remediation workflows
    [X] End-to-end testing
    [X] Documentation

#### In Progress

[~] Advanced Security Features
  [X] Quantum-resistant encryption
    [X] Implementation structure
    [X] CRYSTALS-Kyber integration
    [X] SPHINCS+ signatures
    [X] Hybrid encryption mode
    [X] Test coverage
  [X] Homomorphic encryption
    [X] Implementation structure
    [X] Microsoft SEAL integration
    [X] BFV scheme for integers
    [X] CKKS scheme for floating-point
    [X] Test coverage
  [X] Secure multi-party computation
    [X] Implementation structure
    [X] JIFF library integration
    [X] Secret sharing
    [X] Secure operations
    [X] Test coverage
  [ ] Zero-knowledge range proofs

#### Next Steps (Prioritized)

1. Complete Advanced Security Features
   [X] Implement quantum-resistant encryption
   [X] Implement homomorphic encryption
   [X] Implement secure multi-party computation
   [ ] Prototype zero-knowledge range proofs

2. Start Performance Optimization
   [ ] Plan Redis caching implementation
   [ ] Design database optimization strategy
   [ ] Research service worker integration
   [ ] Plan monitoring system enhancement

### Notes & Considerations

1. Security Focus
   - Maintain zero-knowledge principles throughout
   - Ensure HIPAA compliance in all new features
   [X] Keep security audit trails comprehensive
   [X] Implement real-time violation detection
   [X] Complete remediation workflows
   [X] Implement quantum-resistant encryption
   [X] Implement homomorphic encryption
   [X] Implement secure multi-party computation

2. Performance
   - Monitor impact of security features
   - Plan for scalability
   - Consider edge computing options

3. Documentation
   [X] Keep security documentation updated
   [X] Document all compliance measures
   [X] Maintain clear audit trail documentation

### Current Task: Implementing Zero-Knowledge Range Proofs

Progress:
[X] Research and Analysis
  [X] Investigate Bulletproofs protocol
  [X] Review existing implementations
  [X] Identify key components

[X] Core Implementation
  [X] Create ZKRangeProof service
    [X] Design proof system architecture
    [X] Implement Pedersen commitments
    [X] Add vector operations
    [X] Create inner product protocol
  [X] Add test suite
    [X] Basic range proof tests
    [X] Aggregated proof tests
    [X] Edge case tests
  [X] Implement proof generation
    [X] Add range proof protocol
    [X] Implement Fiat-Shamir transform
    [X] Create proof aggregation
  [X] Add verification system
    [X] Implement proof verification
    [X] Add batch verification

[~] Integration and Testing
  [X] Integrate Bulletproofs with ZKRangeProof service
  [X] Update service interface
  [X] Add serialization/deserialization
  [X] Add comprehensive integration tests
    [X] Single value proofs
    [X] Aggregated proofs
    [X] Performance tests
    [X] Error handling
  [ ] Implement proof aggregation optimization

Next immediate steps:

1. Optimize proof aggregation for better performance
2. Document the implementation details and usage

Implementation Notes:

1. Basic structure and interfaces are complete
2. Test suite covers all major functionality
3. Core Bulletproofs implementation is in place
4. Integration with existing ZK infrastructure is ready
5. Integration tests verify end-to-end functionality
6. TODO: Optimize proof aggregation for better performance

### Lessons Learned from Implementation

1. Protocol Design:
   - Bulletproofs provide efficient range proofs
   - No trusted setup required
   - Support for proof aggregation
   - Logarithmic proof size

2. Performance Considerations:
   - Proof generation is computationally intensive
   - Verification is relatively fast
   - Proof aggregation can significantly reduce size
   - Careful generator selection is important

3. Testing Requirements:
   - Test edge cases thoroughly
   - Verify proof soundness
   - Check proof zero-knowledge property
   - Measure performance characteristics
   - Include integration tests for end-to-end verification
